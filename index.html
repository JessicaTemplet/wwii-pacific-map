<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Righteous Might: Victory over Japan in WWII</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>

<!-- PapaParse (robust CSV parsing) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

<style>
  body { margin:0; font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:#f8f9fa; color:#111; }
  h2 { text-align:center; margin:18px 0 8px; font-size:20px; }
  #timelineWrap { width:95%; max-width:1100px; margin: 0 auto 12px; height:330px; }
  #timeline { width:100%; height:100%; display:block; }
  #map { width:100%; height:720px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); }
  .legend { background: rgba(255,255,255,0.96); padding:10px; border-radius:8px; box-shadow:0 1px 6px rgba(0,0,0,0.12); max-height:260px; overflow:auto; font-size:13px; line-height:1.4; }
  .legend .row { display:flex; align-items:center; margin-bottom:6px; }
  .swatch { width:18px; height:14px; margin-right:8px; border-radius:3px; }
  .symbolImg { width:18px; height:18px; margin-right:8px; display:inline-block; vertical-align:middle; }
  a.source { color:#1F6FEB; text-decoration:none; font-size:12px; }
</style>
</head>
<body>

<h2>Righteous Might: Victory over Japan in World War II</h2>

<div id="timelineWrap">
  <canvas id="timeline"></canvas>
</div>

<div id="map"></div>

<script>
// ---------- Embedded/assets CSV & GeoJSON are expected in repo root ----------
// timeline.csv, points.csv, paths.geojson (you already have them uploaded)

// Utility: safe parse numeric
function toFloat(v){ const n=parseFloat(v); return isNaN(n)? null : n; }

// ---------------- TIMELINE (Chart.js + PapaParse) ----------------
fetch('timeline.csv').then(r=>r.text()).then(txt=>{
  Papa.parse(txt, {
    header: true,
    skipEmptyLines: true,
    complete: function(res){
      const rows = res.data;
      const labels = rows.map(r => r.Year);
      const us = rows.map(r => parseInt(r['US Total Personnel']||0));
      const jp = rows.map(r => parseInt(r['Japan Total Personnel']||0));
      const notes = rows.map(r => r.Notes || '');

      const ctx = document.getElementById('timeline').getContext('2d');
      new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [
            { label: 'US Personnel', data: us, backgroundColor: '#1F6FEB' },
            { label: 'Japan Personnel', data: jp, backgroundColor: '#D0021B' }
          ]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            tooltip: {
              callbacks: {
                afterBody: function(ctx){
                  const i = ctx[0].dataIndex || 0;
                  return (notes[i] ? ('Notes: '+notes[i]) : '');
                }
              }
            },
            legend: { position: 'top' }
          },
          scales: { x: { beginAtZero: true } }
        }
      });
    }
  });
});

// ---------------- MAP (Leaflet) ----------------
const map = L.map('map', { preferCanvas: true }).setView([18, 145], 3);

// tiles
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '© OpenStreetMap contributors'
}).addTo(map);

// pre-defined icon fallbacks (public icons — these commonly allow hotlinking)
const ICONS = {
  bomb: 'https://upload.wikimedia.org/wikipedia/commons/8/8a/Font_Awesome_5_solid_bomb.svg',
  atomic: 'https://upload.wikimedia.org/wikipedia/commons/6/6e/Noun_project_nuclear-explosion_icon.svg',
  flag: 'https://upload.wikimedia.org/wikipedia/en/a/a4/Flag_of_the_United_States.svg'
};

// helper to create an L.icon from a url (with small size)
function makeIcon(url){
  return L.icon({
    iconUrl: url,
    iconSize: [26,26],
    iconAnchor: [13,13],
    popupAnchor: [0,-12]
  });
}

// small cache for icons used
const iconCache = {};
Object.keys(ICONS).forEach(k => { iconCache[k] = makeIcon(ICONS[k]); });

// ---------------- Legend (floating, top-right) ----------------
const legend = L.control({ position: 'topright' });
legend.onAdd = function(){
  const div = L.DomUtil.create('div','legend');
  div.innerHTML = '<strong>Legend</strong><br>';
  div.innerHTML += '<div class="row"><div class="swatch" style="background:#D0021B"></div>Japan offensive</div>';
  div.innerHTML += '<div class="row"><div class="swatch" style="background:#1F6FEB"></div>USA offensive</div>';
  div.innerHTML += '<div class="row"><div class="swatch" style="background:#7A3EE6"></div>Joint operations</div>';
  div.innerHTML += '<div class="row"><img class="symbolImg" src="'+ICONS.bomb+'">Major bombing</div>';
  div.innerHTML += '<div class="row"><img class="symbolImg" src="'+ICONS.atomic+'">Atomic</div>';
  div.innerHTML += '<div class="row"><img class="symbolImg" src="'+ICONS.flag+'">Surrender / flag-raising</div>';
  return div;
};
legend.addTo(map);

// ---------------- Load & Render Points (using PapaParse) ----------------
fetch('points.csv').then(r=>r.text()).then(txt=>{
  Papa.parse(txt, {
    header: true,
    skipEmptyLines: true,
    complete: function(res){
      const rows = res.data;
      // show count in console
      console.log('points.csv rows parsed:', rows.length);

      rows.forEach((row, i) => {
        // get lat/lon from the header names in your CSV (case-sensitive)
        const lat = toFloat(row.lat ?? row.Lat ?? row.Latitude ?? row.Latitude);
        const lon = toFloat(row.lon ?? row.Lon ?? row.Longitude ?? row.Longitude);
        if (lat === null || lon === null) {
          // skip malformed rows but log them so we can inspect
          console.warn('Skipping row (invalid coords) at index', i, row);
          return;
        }

        const label = (row.label || row.Label || row.name || row.Name || '').replace(/^"|"$/g,'');
        const name = (row.name || row.Name || label).replace(/^"|"$/g,'');
        const desc = (row.short_desc || row.Short_desc || row.Description || row.Description || '').replace(/^"|"$/g,'');
        const src = (row.source_url || row.Source_url || row.source || '') .replace(/^"|"$/g,'');
        const color = (row.marker_color || row.Marker_color || '#1F6FEB').replace(/^"|"$/g,'');
        const marker_symbol = (row.marker_symbol || row.Marker || '').replace(/^"|"$/g,'');

        // decide marker type:
        let marker;
        // if marker_symbol is a known keyword -> use our preloaded icon
        if (marker_symbol.toLowerCase() === 'bomb' || marker_symbol === ICONS.bomb) {
          marker = L.marker([lat,lon], { icon: iconCache.bomb });
        } else if (marker_symbol.toLowerCase() === 'atomic' || marker_symbol === ICONS.atomic) {
          marker = L.marker([lat,lon], { icon: iconCache.atomic });
        } else if (marker_symbol.toLowerCase().includes('flag') || marker_symbol === ICONS.flag) {
          marker = L.marker([lat,lon], { icon: iconCache.flag });
        } else if (marker_symbol && marker_symbol.startsWith('http')) {
          // if CSV gives a URL for symbol (some rows do), try to use it
          const u = marker_symbol;
          if (!iconCache[u]) iconCache[u] = makeIcon(u);
          marker = L.marker([lat,lon], { icon: iconCache[u] });
        } else {
          // default: colored circle marker (use provided color)
          marker = L.circleMarker([lat,lon], {
            radius: 6,
            color: "#000",
            weight: 1,
            fillColor: color,
            fillOpacity: 0.9
          });
        }

        const popupHtml = `<strong>${label || name}</strong><br>${desc || ''}${src ? `<br><a class="source" href="${src}" target="_blank" rel="noopener">Source</a>` : ''}`;

        marker.addTo(map).bindPopup(popupHtml, { maxWidth: 320, keepInView: true });
      });
    },
    error: function(err){ console.error('Papa parse error points.csv', err); }
  });
});

// ---------------- Load & Render Paths ----------------
fetch('paths.geojson').then(r=>r.json()).then(geo=>{
  L.geoJSON(geo, {
    style: function(feature){
      // accept either properties.style.color or properties.style.stroke
      const p = feature.properties || {};
      const s = p.style || {};
      const color = s.color || s.stroke || '#666';
      const weight = s['stroke-width'] || s.weight || s['stroke-width'] || 2;
      const dash = s['dashArray'] || s['stroke-dasharray'] || s['stroke-dash'] || '6,4';
      return { color: color, weight: weight, dashArray: dash, opacity: 0.9 };
    },
    onEachFeature: function(feature, layer){
      if(feature.properties && feature.properties.service){
        layer.bindPopup(`<strong>${feature.properties.service}</strong>`);
      }
    }
  }).addTo(map);
}).catch(err => { console.warn('paths.geojson load error', err); });

// ---------------- Fit map to data bounds if available ----------------
// After a short delay (allow fetches), try to fit bounds if many markers exist
setTimeout(() => {
  const group = L.featureGroup();
  map.eachLayer(function(l){
    if (l instanceof L.Marker || l instanceof L.CircleMarker) group.addLayer(l);
  });
  if (group.getLayers().length > 0) {
    try { map.fitBounds(group.getBounds().pad(0.12)); }
    catch(e){ /* ignore */ }
  }
}, 900);

</script>
</body>
</html>
